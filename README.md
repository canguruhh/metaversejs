<p align="center">
  <a href="https://mvs.org/">
    <img src="https://raw.githubusercontent.com/mvs-org/lightwallet/master/src/assets/logo.png" alt="">
  </a>
  <br>
  <a href="https://travis-ci.org/canguruhh/metaversejs">
     <img src="https://travis-ci.org/canguruhh/metaversejs.png?branch=master" alt="Build status">
  </a>
  <br>
  A javascript library for the Metaverse blockchain
</p>

## Installation
Install using npm:
``` bash
npm install metaversejs
```

## Setup
### NodeJS
``` javascript
let Metaverse = require('metaversejs');
```
<a href="https://nodei.co/npm/metaversejs/"><img src="https://nodei.co/npm/metaversejs.png?downloads=true&downloadRank=true&stars=true"></a>
### Browser
For use in webapps the npm package contains a dist/metaverse.min.js. You can generate this file from source using grunt.

## Usage

Please also check the examples folder.

### Wallet generation
``` javascript
let Metaverse = require('metaversejs')

let number_of_addresses = 10

Metaverse.wallet.generateMnemonic()
    .then((mnemonic) => Metaverse.wallet.fromMnemonic(mnemonic)
        .then((wallet) => {
            let addresses = []
            for (let i = 0; i < number_of_addresses; i++) {
                addresses.push(wallet.getAddress(i))
            }
            return {
                "mnemonic": mnemonic,
                "addresses": addresses,
                "wallet": wallet
            }
        }))
    .then(console.log)
```
This will generate a new random wallet and return the mnemonic words as well as the first 10 addresses of the wallet.

### Send ETP or MST
As Metaverse is UTXO based you need to specify the inputs and outputs of the transaction. The following example creates a basic P2PKH (pay to public key hash) transaction.
``` javascript
//Transaction object
var tx = new Metaverse.transaction()
//Add inputs
tx.addInput("MKXYH2MhpvA3GU7kMk8y3SoywGnyHEj5SB","5554b27dbf657d008511df56e747ffb2173749fd933b03317cee3c1fde271aea",1)
//Add outputs
tx.addOutput("MVpxH8aAa3BAXvbdqUUJwEP6s2ajGKKtyd","ETP",1)
tx.addOutput("MKXYH2MhpvA3GU7kMk8y3SoywGnyHEj5SB","ETP",4939995)
console.log('transaction details: ' + tx)
//Sign the inputs
wallet.sign(tx)
    .then( (stx) => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx)
    })
```
You can also add other assets to the transaction. The resulting raw transaction can be broadcasted to any blockchain nodes.

Another way for creating transactions is to use the transaction builder.

``` javascript
const target = {
   "ETP": 100000000,
   "MST": {
      "MVS.HUG": 5
   }
}
Metaverse.transaction_builder.send(utxo, recipient_address, recipient_avatar, target, change_address, change, locked_asset_change, fee, messages)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```

For standard transaction the transaction builder is the preferred way so the next examples will use the transaction builder only.

### Deposit
In order to create a deposit and get interest you just have to add a lock output to a transaction. Possible values for the duration are: 25200, 108000, 331200, 655200 and 1314000 blocks on the mainnet.
``` javascript
Metaverse.transaction_builder.deposit(utxo, recipient_address, quantity, duration, change_address, change, fee, network, messages)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```
The reward transaction will be generated by the miner of the block that will contain the transaction.

### Issue asset
In order to issue a new asset add an asset issue output to a transaction. Please make sure that the asset symbol is unique. Precision must be in range 0..19 and the maximum supply is must be provided as a quantity of the smallest unit. An asset with 1000 tokens that should have a precision of 2 decimals must be provided as 1000000 and precision 2. The transaction fee must be 10 ETP.
``` javascript
Metaverse.transaction_builder.issueAsset(inputs, recipient_address, symbol, max_supply, precision, issuer, description, secondaryissue_threshold, is_secondaryissue, change_address, change, issue_domain, bounty_fee, network)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```

### Send to multiple recipients
``` javascript
const recipients = [ { address: "xxx", "target": { "ETP": 123, "MST": { "SDG": 18 } }, "avatar": "EricGu" } ]
Metaverse.transaction_builder.sendMore(utxo, recipients, change_address, change, locked_asset_change, fee, messages)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```

### Lock MST
``` javascript
Metaverse.transaction_builder.sendLockedAsset(utxo, recipient_address, symbol, quantity, attenuation_model, change_address, change, locked_asset_change, fee, messages)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```

### Issue Avatar
``` javascript
Metaverse.transaction_builder.issueDid(utxo, avatar_address, symbol, change_address, change, bounty_fee, network)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```

### Issue MIT
``` javascript
Metaverse.transaction_builder.registerMIT(utxo, recipient_address, issuer_avatar, symbol, content, change_address, change, fee)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```

### Transfer MIT
``` javascript
Metaverse.transaction_builder.transferMIT(utxo, sender_avatar, recipient_address, recipient_avatar, symbol, change_address, change, fee)
    .then( tx => wallet.sign(tx))
    .then( stx => {
        console.log('signed transaction: ' + stx)
        //Encode (serialize) the transaction
        return stx.encode()
    })
    .then( (raw_tx) => {
        console.log('Encoded transaction: ' + raw_tx.toString('hex'))
    })
```

### Attach message
To attach a message to any transaction there is a function called addMessage. If you use the transaction builder you can use the messages parameter to add an array of messages that will be added to the transaction. For manual addition of messages you can do the following:
``` javascript
//Transaction object
var tx = new Metaverse.transaction();
//Add inputs
tx.addInput("tK8UKnBKhk4NQYhSeSb2zeWgMSZaHsn1TY", "15a3a80a867315ee1d3f1ff67e7d5cd0709b1a1d4a48a938f33b01ec8f47425f", 0);
//Add message
tx.addMessage("tK8UKnBKhk4NQYhSeSb2zeWgMSZaHsn1TY", "hi. this is so easy!");
//Don't forget the change
tx.addOutput("tK8UKnBKhk4NQYhSeSb2zeWgMSZaHsn1TY", "ETP", 299990000);
```

### Decode transaction
You can also easily decode a hex encoded transaction.
``` javascript
Metaverse.transaction.decode(rawtx)
```
Not all information about the previous outputs of the inputs are enoded in a raw transaction. If you want to encode the transaction again you have to add the missing values to the inputs.

## Testing
To run the unit tests just execute:
``` bash
npm test
```



